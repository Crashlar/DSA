''''Prgression Depends  
    When i In collage (do)

''''format - DayName      ---Date        ---- What i learn in brief / detail 
    no code included in the file only theory 



------------------------------------------------------------Now Start-----------------------------------------------------------------------------------------------------
Friday 29/08/2025    Starttime - 7:54 Pm 

Baiscs- 
    Properties of getting Remainder
    if a < b -> a % b = a
    a % (-b)  = a % b 
    (-a) % b = -(a % b )
    (-a) % (-b) = (-a) % b

    variables are starting is not allow with ! @ # % ^ & * ( ) - + .= / | \ ; : '  " and numbers and datatypes but start with underscore like _int is allow 





    typecast 
    '''
        int x ;
        float y ;

        y= (float)x;
        cout << y ;
    
    '''

    hyrarcy level 
        - left to right 


            Operator	Name	Associativity
            () [] -> .	Function call, Subscript, Member access	Left
            ++ --	Increment/Decrement	Right
            ! ~ - +	Logical/Bitwise NOT, Unary plus/minus	Right
            * / %	Multiplication, Division, Modulus	Left
            + -	Addition, Subtraction	Left
            << >>	Bitwise shift	Left
            < <= > >=	Relational operators	Left
            == !=	Equality operators	Left
            &	Bitwise AND	Left
            ^	Bitwise XOR	Left
            |	Bitwise OR	Left
            &&	Logical AND	Left
            ||	Logical OR	Left
            ?:	Ternary conditional	Right
            = += -= *= /= %= &= ^= |= <<= >>=	Assignment and compound assignment	Right
            ,	Comma	Left



    Taking Input in C++
    ➤ Using cin for Basic Input
    C++ leverages the standard input stream std::cin to receive data from the user.


        int age;
        std::cin >> age;
    This reads an integer input and stores it in age.

    ➤ Reading Multiple Values
        int x, y;
        std::cin >> x >> y;  // Accepts two integers separated by space or newline
    ➤ Strings and Common Pitfall
    While cin reads strings without spaces, to read full lines (like names or sentences), use getline():

        std::string name;
        std::getline(std::cin, name);
    If getline() is used after cin, make sure to flush the newline character:

        std::cin.ignore();  // Clears leftover newline from input buffer

    2. Operator Precedence & Associativity
    C++ has a rich set of operators. Understanding which operator is evaluated first is crucial when expressions contain multiple operators.

    Operator Precedence Table (Top 10)
    Precedence	Operator(s)	Associativity	Description
            1 (Highest)	::	None	Scope resolution
            2	++ -- () []	Left-to-right	Postfix
            3	+ - ! ~ * &	Right-to-left	Unary
            4	* / %	Left-to-right	Multiplication/Division
            5	+ -	Left-to-right	Addition/Subtraction
            6	<< >>	Left-to-right	Bitwise Shift
            7	< <= > >=	Left-to-right	Relational
            8	== !=	Left-to-right	Equality
            9	&&	Left-to-right	Logical AND

    Best Practice: Always use parentheses to ensure clarity and avoid relying solely on operator precedence.

    Example:

        int result = 10 + 5 * 2;  // Multiplication happens before addition => 10 + (5*2) = 20

    3. Type Casting in C++

    When different data types are mixed in expressions, type conversion plays a key role. C++ offers both implicit and explicit casting.

    ➤ Implicit Type Conversion
    Occurs automatically when operands differ in type.

    int a = 5;
    float b = 2.5;
    float result = a + b;  // `a` is promoted to float

    ➤ Explicit Type Casting (Manual)
    C-style Cast:

        float result = (float) a / b;

    C++-style Cast (Preferred):

        float result = static_cast<float>(a) / b;

    C++ Cast Types
    Cast Type	Purpose
    static_cast	Normal conversions (int ↔ float, base ↔ derived)
    dynamic_cast	Runtime-safe casting for polymorphic types
    const_cast	Adds or removes const
    reinterpret_cast	Bitwise reinterpretation (unsafe, low-level)

    Avoid reinterpret_cast unless you're sure of what you're doing.


____________________________________________________________Day 2_______________________________________________________________________________________________
Sunday 31/08/2025     Starttime - 4:10 Pm 

Conditional - 
    To find modulus or absolute values 
        abs() , negative()

    Conditional func
        if
        else
        else if 

    For multiple Condition in one use 
        && 
        ||
        or
        and

    always use bracket don't depends on hierarcy  of order
        (3 + 4 ) * 45 - (4 / 5)

    better understanding in else-if go with showgrade.cpp

Switch -> 
    switch syntax
        -    switch(expression){
                case expression1: 
                // code
                break; 
                case expression2:
                code 
                break;
                case expression3:
                // code
                break;
                as so on 
            }


    What 
        switch statement is a flow control statement that is used to execute the different blocks of statements based on the value of the given expression. It is an alternative to the long if-else-if ladder which provides an easy way to execute different parts of code based on the value of the expression.


    Working of switch case 
        firstly match with case value then evaluate the case code if no any case matched then the default case automatic executed 

    Rules of Switch statement
        case value must be int or char datatype
        You can have as many case blocks as needed.
        duplicate case value are not allowed in any situation 
        A break statement is optional in each case.

____________________________________________________________Day 2 Extend_______________________________________________________________________________________________
Sunday 31/08/2025    Starttime - 10 Pm


Pattern-Printing -> 
    Tips-
        break all in single single terms 
        start printing with small terms 
        end..

        -Don't break the i , j structure if possible have you 

    Summarize - 
        1. Square/ rectangle ka structure (i -> 1 to n   j -> 1 to n )
        2. Triangle 
            1. i -> 1 to n 
                j -> 1 to i 
            2. i -> 1 to n 
                j -> 1 to n + 1 - i 
            3. i -> 1 to n 
                j -> 1 to n - i 
                k ->  1 to i   
        3. Maths -> use brain power 

    Common Pattern Categories : 
        Category	                  Example	                    Key Logic
        Rectangular	           ***** (5x5 square)	               Equal rows & columns
        Right-Angled	            * → *****	                    Stars = Row No. (i)
        Inverted	                 ***** → *	                    Stars = n - i
        Pyramid	               Centered triangle	               Spaces + Stars
        Diamond	               Pyramid + Inverted	               Split into 2 parts
        Number-Based	          1 22 333                      	Print row number
        Alphabet-Based	          A BB CCC	                         char('A' + i)


    Step-by-Step Approach :
        (1) Observe the Pattern
            Count rows, columns, spaces, and symbols.
            Check if it's growing/shrinking.

        (2) Find Row-Column Formula
            Relate i (row) and j (column) to the pattern.
            Example:
                Hollow Rectangle:
                        Print * only at borders (i==0, i==n-1, j==0, j==m-1).

        (3) Handle Spacing (if needed)
            Use cout << " "; before stars for pyramids/diamonds.

        (4) Test with Small n
            Verify logic for n=3 or n=4 before scaling.
____________________________________________________________Day 3_______________________________________________________________________________________________
Monday 1/09/2025     Starttime - 10 Am  eg along the day 2

loops-

    What and Why -
        sometimes there is a need to perform some operation more than once or (say) n number of times.
        -(or)
        koi bhi multiple times karni ho jo ek pattern se connected ho 
        
    loops
        for ( initialization; test condition; updation) { 

        // code

        }
            -steps of loop works 
                // check 
                // inside loop 
                // increment / decrement
                // repeat

        Initialization: 
            Initialize the loop variable to some initial value.

        Test Condition:
            This specifies the test condition. If the condition evaluates to true, then body of the loop is executed, and loop variable is updated according to update expression. If evaluated false, loop is terminated.

        Update Expression: 
            After executing the loop body, this expression increments/decrements the loop variable by some value.

        Note:
            The loop variable can also be declared in the initialization section but the scope of the loop variables that are declared in the initialization section is limited to the for loop block.


    While loop 
        while (condition) {
        // Body of the loop
        update expression
        }

        The various parts of the While loop are:

        Condition: 
            The loop executes its body till this condition remains true.
        Update Expression:
            Update the value of loop variable to make it closer to the termination condition.
        Body:   
            It is a group of statement that will be executed till the condition remains true.
        

    do-while 
        do {
            // Body of the loop
            // Update expression
        } while (condition);
        
        When the program control first comes to the do…while loop, the body of the loop is executed first and then the test condition/expression is checked, unlike other loops where the test condition is checked first. Due to this property, the do…while loop is also called exit controlled or post-tested loop.

        When the test condition is evaluated as true, the program control goes to the start of the loop and the body is executed once more.
        
        The above process repeats till the test condition is true.
        
        When the test condition is evaluated as false, the program controls move on to the next statements after the do…while loop.


    break
        Syntax 
            break;
        stop when the condtion true 
        A break statement is used when we want to terminate the running loop whenever any particular condition occurs. Whenever a break statement occurs loop breaks and stops executing.
        The Break statement is used to exit from the loop constructs.
        The break statement is usually used with the switch statement, and it can also use it within the while loop, do-while loop, or the for-loop.
        When a break statement is encountered then the control is exited from the loop construct immediately.
        Break statements uses switch and label statements.
        Leftover iterations are not executed after the break statement.


    Continue 
        Syntax
            continue;
        is used when we have to skip a particular iteration. Whenever we write continue statement the whole code after that statement is skipped and loop will go for next iteration.
        The continue statement is not used to exit from the loop constructs.
        The continue statement is not used with the switch statement, but it can be used within the while loop, do-while loop, or for-loop.
        When the continue statement is encountered then the control automatically passed to the beginning of the loop statement.
        label statements.	It does not use switch and label statements.
        Leftover iterations can be executed even if the continue keyword appears in a loop.


Function- 
    function - 
        y = f(x) = x^2 + 3 
            f(x) -> output
            x^2 + 3 -> input

    What is int main()-
        - main function always works firstly then others func 
        - this is only once  created 

    Syntax- 
        <void/int/float> function_name(int a  , int b , int c ){
            function_body 
        }

    Builtin Function    
        - min()
        - max()
        

    Me :-
    Function Basic :-  
        Definition & Declaration: 
            A function is a building block of C++ programs that contains a set of statements which are executed when the functions is called. It can take some input data, performs the given task, and return some result. A function can be called from anywhere in the program and any number of times increasing the modularity and reusability.
        
            Syntax : 
                return_type name() {
                // Function body
                }
        Return types (void, int, etc.): 
            Void functions do not have a return type, but they can do return values
                1. A Void Function Can Return: We can simply write a return statement in a void fun(). In fact, it is considered a good practice (for readability of code) to write a return; statement to indicate the end of the function.
                ``` code 

                2. A void fun() can return another void function: A void function can also call another void function while it is terminating.
                ``` code
                // C++ code to demonstrate void()
                // returning void()
                #include <iostream>
                using namespace std;

                // A sample void function
                void work()
                {
                    cout << "The void function has returned "
                            " a void() !!! \n";
                }

                // Driver void() returning void work()
                void test()
                {
                    // Returning void function
                    return work();
                }

                // Driver Code
                int main()
                {
                    // Calling void function
                    test();
                    return 0;
                }
                ```

                3. A void() can return a void value: A void() cannot return a value that can be used. But it can return a value that is void without giving an error
                ``` code 
                // C++ code to demonstrate void()
                // returning a void value
                #include <iostream>
                using namespace std;

                // Driver void() returning a void value
                void test()
                {
                    cout << "Hello";

                    // Returning a void value
                    return (void)"Doesn't Print";
                }

                // Driver Code
                int main()
                {
                    test();
                    return 0;
                }
                ``` end

        Function calling : 
            - Function Calling involves specifying the function's name followed by parentheses(). If the function requires input values, known as parameters, then they are passed inside the parentheses as arguments. When the function is called, the program execution jumps to the function's code block, executes it, and then returns control to the point in the program where the function was called.
            // calling the function
            function_name(argument_1, argument_2, argument_3, ...)

    Function Parameters :
        Pass by value -  
            When you pass a parameter by value, the function receives a copy of the original value. The function works with this copy, and any changes made to the parameter inside the function do not affect the original value outside the function.

            Key Points:
                - The original data remains unchanged because the function operates on a copy.
                - This is safe because the original value is protected from modification.
                - It can be less efficient for large data (like big objects or structures) because copying takes time and memory.
        Pass by reference (int &x) : 
            When you pass by reference, the function receives the actual original variable, not a copy. Any changes made to the parameter inside the function will affect the original value outside the function.

            Key Points : 
                - The original data can be modified by the function.
                - This is efficient because no copy is made, even for large data.
                - Useful when you want the function to modify the original variable or avoid the overhead of copying.

Pointer-> 
    Pass by pointer (int* x) : 
        When you pass by pointer, the function receives the memory address (pointer) of the original variable. The function can use this address to access or modify the original value.
        Key Points:
            - Like pass by reference, the original data can be modified by the function.
            - Requires explicit dereferencing to access or modify the value (unlike references, which work like the  original variable).
            - Pointers can be reassigned to point to other data, while references cannot be reassigned after initialization.
            - Can be used to pass "null" (no data), which is not possible with references.


    all output value are same 

    Double Pointer - 
        used to store address of a single pointer 


    Pointer- 
        A pointer is a variable that stores the address of another variable. 
        Create Pointer - 
            data_type* variable_name 
            <!--  A pointer can be declared in the same way as any other variable but with an asterisk symbol (*) -->

    Address-of Operator (&) : 
        The & operator is used to obtain the memory address of a variable.
        It creates a pointer that "points to" the variable's memory location.

    Dereference Operator (*) : 
        The * operator is used to access the value stored at the memory address a pointer is pointing to.
        It allows you to manipulate the value indirectly through the pointer.
        
    Null Pointer - 
        A NULL pointer is a pointer that does not point to any valid memory location but NULL. It is often used to initialize a pointer when you do not want it to point to any object.
    //    good practice of using pointers
            int* ptr1 = 0;
            int* ptr1 = '\0';
            int* ptr1 = NULL;

    ## Example of the Pointer assignment
    ``` bash 
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int a = 10;
        int b = 99;

        int *ptr = &a;
        cout << *ptr << endl;
        
        // Changing the address stored
        ptr = &b;
        cout << *ptr;
        
        return 0;
    }
    ```
    [!image](https://media.geeksforgeeks.org/wp-content/uploads/pointers-in-c.png)


    Size of Pointer-
        8 bytes for a 64-bit System
        4 bytes for a 32-bit System


    Advantage of Using Pointer 
        - Pointers are most efficient in handling arrays and other data structures.
        - Pointers can return multiple values from a function through function arguments.
        - Pointers can be used to reference a function and hence it enables passing of a function as an argument to another function.
        - Pointers save a lot of space in storage memory by offering the use of pointer arrays to character strings.
        - Pointers support dynamic memory allocation in Data Structure.
        - Pointers enables a user to manipulate dynamic data structures such as linked lists, queues, stacks, and trees


    Chain of Pointers: 
        - chain of pointer is created when we make a pointer to point to another pointer and it may continue further 
        [!image](https://codedec.com/wp-content/uploads/2020/10/3-1.png)

    Passing address to Functions :
        - We can pass the address of a variable as an argument to a function.
        call by reference : 
            The process of passing the addresses of variable to a function using pointer is called as call by reference
        class by Value :
            The process of passing the actual values of variables to a function is known as Call by Value
            Example: Program to swap values of two variables using pointer operation: 
                
                ``` code 
                #include <iostream>
                using namespace std;  
                void swap (int *x, int *y)  
                {  
                int temp;   
                temp = *x;  
                *x=*y;  
                *y=temp;
                }
                // main function 
                int main()  
                {  
                int x = 2;  
                int y = 4;   
                cout << ("x is %d and y is %d before swapping\n",x,y)<< endl;
                swap(&x,&y);
                        
                cout << ("x is %d and y is %d after swapping\n",x,y);
                return 0;
                }  
                ```
    Returning Pointers from Functions: 
    ``` code
        #include<stdio.h>
        int *Large(int *, int *);
        int main()
        {
        int a=5,b=10,*p;
        p = Large(&a,&b);
        
        printf("Larger number between %d and %d is %d.",a,b,*p);
        }
        int *Large(int *x, int *y)
        {
        if(*x>*y)
        return (x);
        else
        return (y);  
        }
    ```

---Function Overloading---  
Function Overloading : 
    Function overloading improves clarity and reusability in DSA by letting one function name handle multiple variants. It’s widely used in sorting, searching, graph algorithms, and math operations to keep code clean and intuitive.
    Why Use Function Overloading in DSA? : 
        1. Improves Code Clarity
            Instead of having different names for similar operations (e.g., search_array, search_linkedlist), we use one logical name (search) with different parameters.
            Example:
                sort(arr) for arrays
                sort(list) for linked lists

        2. Handles Different Data Types
            A single function name can work with int, float, string, etc., reducing the need for redundant functions.
            Example:
                max(5, 10) (integers)
                max(3.14, 2.71) (floats)

        3. Supports Multiple Input Formats
            Useful when an algorithm can accept inputs in different forms (e.g., array + size vs. vector vs. range).
            Example:
                binary_search(arr, size, key)
                binary_search(vec.begin(), vec.end(), key)

        4. Default Parameters + Overloading for Flexibility
            Can combine overloading with default arguments to reduce redundant functions.
            Example:
                print(arr) → prints entire array
                print(arr, start, end) → prints a subrange

        5. Polymorphic Helper Functions
            In recursive algorithms, helper functions can be overloaded to simplify the API.
            Example (QuickSort):
                quicksort(arr) → public interface
                quicksort(arr, low, high) → internal recursion


---Array---  
Array-> 
    What is an Array - 
        array is a DatStructure -> storage to store data 

    Syntax and Declaration -
        datatype var_name[item_n] = {itm1 , itm2 , itm3 , ..... , itm_n};

    Memory allocation in Array -
        Continuous Memory allocation
        int arr[4] = {1 , 3, 4, 5};

---Vector---  
Vector-> 
    Vector in C++
        replacement of array
        ploblem -
            array has fixed size 
            int arr[5] = { 1, 2 , 3,4,5}
            if i want to change the size then it is possible to go to change in our code 
        
        Vector is Dynamic array that change our size when required
        syntax- 
            vector<int> arr; 
        
        function in Vector -
            push_back -> intialize a value on the last box of vector 

            pop_back -> delete a back box value
            
            size ->how many box filled already
            
            capacity -> how many box in vector 
            
            at -> know exact position value

        
    Passing Vectors to function : 
        by value. Each time you pass , new vector is created if (&) is not passed to vector<int> v in function 

        vector<int> &v 
            this is point to same reference so the value is change in main function and not created new 
____________________________________________________________Day 4_______________________________________________________________________________________________
Tuesday 02/09/2025     Starttime - 10 Am  

---Vector---  
2D Vectors-> 

        vector<vector<int> > v;
        vector<vector<int> > v(m);  
            m is size
        vector<vector<int> > v(m , vector<int> (n));
            m is rows
            n is cols
        vector<vector<int> > v(m , vector<int> (n , k ));
            m is rows
            n is cols
            k is value in each box 

    Advantages of vectors over arrays
        1. Increase your rows
        2. Variable Columns

        only possible in vector in box intialization
            |   |
            |   |   |
            |   |   |   |
            |   |   |

    Vector-
        2D Vector are vector of vector

    Advantages of Vector- 
        Passing of 2D arrays into Functions -> Problem 
            Soln = We have to mention rows and cols every time


    Basic STL Functions in Vector
        push_back()
        pop_back()
        begin()
        end()
        rbegin()
        rend()
---String---  
String -> 
    What are strings and Why are they used 
        - 
    Declaration of strings and Taking input 
        - string str = "Name";
        cout << str;


    Built-in string
        - size() / length() 
        - push_back()   
            only single character allow
        - pop_back()
            last character is deleted 
        - (+) operator
            append the character only not number 
        - revese
            // in #include<algorithm>
        - substr()

        - to_string()
            Its convert integer to string
        - etc


____________________________________________________________Day 5_______________________________________________________________________________________________
Thrusday 04/09/2025     Starttime - 10 Am 

---Time-Space-Complexity---
Time-Space-Complexity ->
    Notation for Differnt types of Time Complexity 

        Big O Notation 
            O(n)
                O(n+ k ) is = O(n)
                always takes the highest power 
            O(n^2)
            O(logn)
            O(2^n)
            O(1)
            Where n is usually size of array / data structure 

    Space Complexity
        - Study of all extra space used in terms of given 'm' , 'n'
        O(1)
            constants 
        O(n+m)
        O(n*m)

---Sorting---    
Sorting -> 

    What is Sorting ? 
    arr[4] = {5 , 3, 2 , 6};
        to sort = Put in ascending order 
            sort(v.begin() , v.end())
            reverse(v.begin() , v.end())
        sort in descending order = put the element in descending order 

    Bubble sort Algorithm
        arr[] = { 5 , 1 , 4 , 3 , 2};

        check both adjacent element and if first one is greater than swap both and move on linearly 
        
        arr[] = 5 , 1 , 4 , 3 , 2 
            last element on best position to don't move 
            1st pass = 1 , 4, 3, 2 , 5 
            2nd Pass = 1 , 3 , 2 , 4 , 5 
            3rd Pass = 1 , 2 , 3 , 4 , 5 

        Worst case :- 
            arr[] = 5 , 4 , 3 , 2 , 1 
                1st pass = 4 , 3 , 2 , 1 , 5  
                2nd Pass = 3 , 2 , 1 , 4 , 5
                3rd Pass = 2 , 1 , 3 , 4 , 5
                4th Pass = 1 , 2 , 3 , 4 , 5
        
        Observation 
            In each pass the nth max element goes to its right position 
            if there are n elements , then we require atmost(jyada se jyada) 'n-1' passes to sort 
        Algorithm-
            In each pas swap two adjacent elements if arr[i] > arr[i+1]
            Iteration in each pass also reduces 


        Can We optimize it further
            Ques - Given an array , find if it is sorted or not 
            Ans-
                arr[] = {1 , 2, 3,4}
                bool flag = true
                for( int i = 0 ; i < n -1 ; i++){
                    if ( arr[i] > arr[i+1]){
                        flag = false;
                        break;
                    }
                }
                if( flag) -> sorted 

    Stable and Unstable Sort 
        arr[] = {5 , 3, 5, 1, 2}

        After sort =
            stable sort - 1 , 2, 3 , 5 of 1 , 5 of 2
            Unstable sort -1 , 2, 3 , 5 of 2 , 5 of 1
        Conclusion - Bubble sort is a stable sort


    -Selection sort Algorithm
        arr[] = {5 , 3 , 1 , 4 , 2 }
        1 , 3, 5 , 4 , 2 
        1 , 2, 5 , 4 ,3 
        1 , 2, 3, 4, 5
        sorted  = 1 , 2, 3, 4, 5
        steps-
            array me min ko swap kar do 
            n-1 total swaps
            
    -Time complexity and Space complexity
        time complexity - O(n^2)
        Space complexity - O(1)
    -Stability
        stable and unstable - use wiki 
        
        -usecases  
            cost of swapping starting se 'k' minimun element out of n , if size of arrary is small 
    -Insertion sort Algorithm
        arr[] = 5 , 3 , 1 , 4 , 2
                5 | 3 , 1 , 4 , 2 
                3 , 5 | 1 , 4 , 2
                1 , 3 , 5 | 4 , 2 
                1 , 3 , 4 , 5 | 2 
                1 , 2 , 3 , 4 , 5 | 
            start from second element first is already sorted if 3 is smaller than 5 than swap  
            if 1 is smaller than 5 then swap then if 1 is smaller than 3 so swap each 
            remaining element sorted accordinaly 
                5 , 3 , 1 , 4 , 2 
                3 , 5 , 1 , 4 , 2 
                3 , 1 , 5 , 4 , 2 
                1 , 3 , 5 , 4 , 2
                1 , 3 , 4 , 5 , 2  
                1 , 3 , 4 , 2 , 5
                1 , 3 , 2 , 4 , 5 
                1 , 2 , 3 , 4 , 5  
            -code
                for( int i = 0 ; i <= n -1 ; i++){
                    int j = i ; 
                    while ( j >= 0){
                        if ( arr[j] >= arr[j-1]) break;
                        if(arr[j] < arr[j-1]){
                            swap(arr[j], arr[j-1]);
                            j--;
                        }
                    }
                }

    Time complexity and Space complexity
        Time complexity - O(n^2)
        space complexity - O(1)
    Stability of both
        only adjacent swap just like bubble sort 



____________________________________________________________Day 6_______________________________________________________________________________________________
Thrusday 04/09/2025     Starttime - 11 Pm 

---Binary & linear Search---
Binary  & Linear Search -> 
    What and Why 
        arr[] = { 1 , 2, 4 , 5 , 9, 15 , 18 , 21};
        target = 18 

        // approach 1  linear Search 
            // code
            bool flag = false ; // target not present 
            for ( int i = 0 ; i < n ; i++){
                if(arr[i] == target ){
                    flag = true;
                    break;
                }
                // Time complexity O(n) 
            }

            if ( flag ) cout << "PResent";
            else cout << "Absent"; 
            
        // Approach 2  binary search
            Works only if array is sorted (noth ascending or descending)
            Works on indeces
            firstly maintain low_index , high_index
            int mid = (low_index + high_index)/2

            // thinking process
            arr[] = { 1 , 2, 4 , 5 , 9, 15 , 18 , 21};
            int mid  =( lo + hi )/  2
            if ( arr[mid] == target ) return true ; 
            if ( arr[mid] < target ) lo = mid + 1 ; 
            if ( arr[mid] > target ) hi = mid - 1 ;   
            
---Recursion---
Recursion->
    What?
        replacement of loops
        function calling itself 

    What are Function Call
    // base 
    // kaam 
    // call 
    // kaam 
    // return 

-----OOP----
OOP
    object oriented Programming is a methodology or paradigm to design a program using classes and objects 

    Data Abstraction 
         - creating a layer and hide meaningful code 
         - security 
    Data Encapsulation 
         - creating private to secure access from outsider 
    Inheritance
         - inherit class from parents
    Polymorphism
         - overloading
         - overriding 

    What are classes? 
        class is a User-defined datatype.
        class is a blueprint (blueprint means how this shown )

    What is object ? 
        object is an instance of the class (instance means a shadow)

    Array Approach vs class
        choosing between an array-based approach and a class-based approach depends on the complexity and purpose of your code. Arrays are simple, lightweight, and efficient for handling fixed-size data with minimal overhead. They’re ideal for quick tasks like storing scores or iterating over values when you don’t need much logic attached. However, arrays lack encapsulation and safety features—there’s no built-in bounds checking, and you have to manually implement operations like sorting or searching. On the other hand, classes offer a structured and scalable way to manage data and behavior together. By wrapping arrays inside classes, you gain the ability to add validation, abstraction, and reusable methods, making your code more maintainable and beginner-friendly. This is especially useful when building modular tools, GUI/CLI interfaces, or open-source projects where clarity and contributor experience matter. While arrays serve well for raw performance and simplicity, classes empower you to design systems that grow with your needs, support collaboration, and align with best practices in modern C++ development.

    Getter 
        accessors (as they access the value), are the public member functions that are used to fetch private member's values. In general, the getter starts with the word “get” followed by the variable name.
    Setter
        known as mutators (as they update the value), are also the public member functions that set the value of a private member variable. In general, the setter starts with the word “set” followed by the variable name.
        
    Static Vs Dynamic Allocation 
        memory allocation can be broadly categorized into static and dynamic allocation, each serving different purposes depending on the program’s needs. Static allocation occurs at compile time, meaning the memory for variables is reserved before the program runs. These variables typically reside in the stack and are automatically managed by the compiler. This approach is faster and safer, as it avoids manual memory management, but it lacks flexibility—especially when the size of data structures isn’t known in advance. On the other hand, dynamic allocation happens at runtime, allowing developers to request memory from the heap using operators like new and delete. This method is ideal for scenarios where the size or lifetime of data structures is unpredictable, such as when building linked lists, trees, or buffers based on user input. However, dynamic allocation requires careful handling to avoid memory leaks and dangling pointers. While static allocation is best suited for fixed-size arrays and simple variables, dynamic allocation shines in more complex, scalable applications. Choosing between the two depends on the trade-off between performance, flexibility, and control over memory management.

    class in class 
        A nested class is defined within the scope of another class. It behaves like any other member of the outer class, but with some important access rules:
        The nested class does not automatically have access to the private members of the outer class.
        The outer class can access the nested class if it's declared public.

    Array of objects
        an array of objects refers to a collection of instances of a class stored in contiguous memory locations. This allows you to manage multiple objects with similar properties and behaviors efficiently. Each element in the array is an object, and you can access its members using the array index and dot operator.

    Constructor
        constructor banana is best for the class to pass the value and and auto connected to system 
        is very very similar to function
        mandatory for class 
        Hidden function 
        object Creation 
        1. Default Constructor -.always exist in form of hidden in class
        2. Parameterized Constructor -.
        3. Copy Constructor -.
    
    Destructor
        Destruction 
        Constructor object create 
        Constructor object destroy
        -. is maintain to freeup the  memory 

    Shallow and deep Copy
        Shallow copy is like copying a house key—you and the other person now access the same house.
        Deep copy is like building a second house with the same design—each person has their own space.
      
    Static members
        The static keyword is used with a variable to make the mmory of  the variable static once a static variable is declared its memory can't be changed 
        'ClassName::Startfunc'
        :: outsider the functions(scope)
        ClassName::  calling the class value(scope)

    Intialization list 
            short way to declare the constructor 
            ClassName(int i, string n) : attribute1Name(i), attribute2Name(n) {
                // Constructor body (optional logic)
            }

    Function overloading(compile time )
        creating functions with same name but different parameters
        parameter is not same as count(parameter)
        allowed is only name same but different parameter 

        1. compile time Polymorphism
            - function overloading
            - operator overloading
            also known as static polymorphism or early binding—refers to the ability of the compiler to determine which function or operator to invoke at compile time, based on the context. This makes your code more efficient and flexible, especially when you're designing reusable components or modular tools.
        2. runtime Polymorphism
            - function overriding
            also known as dynamic polymorphism or late binding—occurs when the decision about which function to invoke is made during program execution, not at compile time. This is a cornerstone of object-oriented programming and enables flexible, extensible designs.

    Inheritance
        Access the public and protected members of the base class.
        Override or extend functionality.
        Avoid rewriting common logic.

        # The Hierachicy of the access specifier or class Inheritance
            |----------|---------------------------------------------|
            |Mode	   | Effect on Base Members in Derived Class     |
            |----------|---------------------------------------------|
            |public    |	Public → Public, Protected → Protected   |
            |----------|---------------------------------------------|
            |protected |	Public → Protected, Protected → Protected|
            |----------|---------------------------------------------|
            |private   | Public & Protected → Private                |
            |----------|---------------------------------------------|
        
        1.Single Inheritance
        Single inheritance in C++ is the simplest form of inheritance, where one class (called the derived class) inherits from exactly one other class (called the base class). This creates a one-to-one relationship, allowing the derived class to reuse and extend the functionality of the base class.

            In single inheritance:
                The derived class inherits public and protected members of the base class (depending on access specifier).
                Private members of the base class are not directly accessible in the derived class.
                It promotes code reuse, modularity, and specialization.
        
        2. multiple Inheritance
            Multiple inheritance in C++ allows a class to inherit from more than one base class, combining their properties and behaviors into a single derived class. This is a powerful feature, but it comes with complexity—especially when base classes share common members
            
            In multiple inheritance:
                A derived class can inherit from two or more base classes.
                It gains access to all accessible members of each base.
                Constructors of base classes are called in the order they appear in the inheritance list.

        3. multi-level Inheritance
            Multilevel inheritance in C++ is a type of inheritance where a class is derived from another derived class, forming a chain of inheritance across multiple levels. It’s like a family tree: a grandparent class, a parent class, and a child class, each building on the previous one.

            In multilevel inheritance:
                This allows the most derived class to reuse and extend features from multiple layers of abstraction.
        
        4. Hierachical Inheritance
            Hierarchical inheritance in C++ occurs when multiple derived classes inherit from a single base class. It’s like a tree branching out from one trunk—each subclass gets access to the common features of the base class, but can also define its own unique behavior.
            
            In hierarchical inheritance:
                One base class serves as the parent.
                Two or more derived classes inherit from it independently.
                Each derived class can use the base class’s members and add its own
        
        5. Hybrid Inheritance    
            Hybrid inheritance in C++ is a combination of two or more types of inheritance—such as single, multiple, multilevel, and hierarchical—within a single class hierarchy. It’s like mixing different architectural styles to build a flexible, reusable, and scalable structure. This form of inheritance allows developers to model complex relationships between classes while maximizing code reuse.

            In hybrid inheritance:
                A class may inherit from multiple classes (multiple inheritance).
                Those base classes may themselves be part of a multilevel or hierarchical inheritance chain.
                The result is a multipath inheritance structure, which can introduce ambiguity if not carefully designed.

    Diamond Problem 
        When 2  instance of base classes are present in the derived class
        B derives A , C derives A and D derives B + C.
        Now D has 2 instance of A 

        we use virtual inheritance so that B and C share a single instance of A, and D inherits that shared instance
    
    Function overriding(Runtime)
        When a function of base class is redefined in it's derived class, it's called function overridding 
        Accessing through scope resolution operator
        Accessing through pointer.

        means-. sons forcefully takes properties from parents

    Virtual Function
        Virtual functions makes sore the correct function is called for an object, regardless of the pointer used for calling it. 

    Abstract Class
        have pure virtual function 
        declare in the base class 

    Friend Function 
        A friend function in C++ is a powerful feature that allows a non-member function to access the private and protected members of a class. It’s like giving a trusted outsider a backstage pass to your class’s internal data—without making them a full member.

        Why uses ?
            To allow external functions or other classes to interact with private data.
            To enable operations involving multiple classes, like comparing or combining objects.
            To maintain encapsulation while selectively exposing internals.

        |-----------------|---------------------------------------------------------|
        | Feature	      | Description                                             |
        |-----------------|---------------------------------------------------------|
        | Not a member	  | Friend functions are not members of the class           |
        |-----------------|---------------------------------------------------------|
        | Declared inside |	Must be declared inside the class using friend keyword  |
        |-----------------|---------------------------------------------------------|
        | Defined outside |	Defined like any normal function                        |
        |-----------------|---------------------------------------------------------|
        | Access level	  | Can access private and protected members                |
        |-----------------|---------------------------------------------------------|

    Const keyword
        The const keyword in C++ is a powerful tool that enforces immutability, meaning it prevents variables, pointers, functions, or objects from being modified after they’re defined. It’s all about protecting data and making your code safer, clearer, and more predictable.
        Must be initialized at declaration.
        Cannot be changed later.
        Great for fixed values like limits, configuration, or mathematical constants.


---linked list/note---
____________________________________________________________Day 7_______________________________________________________________________________________________
Thrusday 08/09/2025     Starttime - 10 Am 


Linked-list
    Linked List
    can't follow continuous memory 
    collection of nodes 
    wastege is lower than array 
    insert or shift -> o(1) [provided location are known]
    on runtime dynamically grow and shnk further 

    Linked list is a collection of node it is a linear data structure with non- contigous memory location through created 

    
    magical-Linked # mine
        L.L in Hindi 

    Types 
        1. Singly linked list 
        2. doubly linked list
        3. circular Singly linked list
        4. circular Singly linked list

    
    Insert at head 
        make sure use pass by reference 
    

____________________________________________________________Day 8_______________________________________________________________________________________________
Thrusday 15/09/2025     Starttime - 10 Am

Stacks

    What is Stacks?
        provides us discipline 
        provides us intuition 
        called as LIFO (last in First out )  / FILO (first in last out )
        Stack size is unlimited as linked list 
        Example- CD Rack
    
    If I want to access the cd of middle place 
        1. Insertion of element in Stack only happens at the top 
        2. Deletion of element in Stack only happens at the top 
        3. get element only happens at the top 
    
    Operation on Stack
        1. st.push(variable)
            add a new element at the top 
        2. st.pop() 
            Deletion of the yop element 
        3. st.top()
            access the top value / element 

    No setting in Stack like first remove top then insert or place variable on top 

    STL for Stack
        stack<int> st; 
            Operation using :
                st.push();
                st.pop();
                st.top();
                st.size();
                st.empty();
        vector<int> v ; 
            for vector 

    How to Print element of a stack ? 
            while (st.size() > 0)
            {
                cout << st.top() << " ";
                st.pop();
            }
                But the problem is that the stack is totally deleted after print
                so we will using the temp variable as a copy of original stack 
                USING THIS CODE ```
                    stack<int> temp;
                    while (st.size() > 0)
                    {
                        cout << st.top() << " ";
                        temp.push(st.top());
                        st.pop();
                    }

                    // putting element back from tem to st

                    while (temp.size() > 0 )
                    {
                        st.push(temp.top());
                        temp.pop();
                    }
                    ````

    Comparing Arrays, Linked Lists and Stacks     
        Time Complexity and Space Complexity 

        |------------|---------------|------------------|
        |       arr  | LL            |stack             |    
        |------------|---------------|------------------|
        |0(1) 0(1)   | 0(n) 0(1)     | 0(n)  0(n)       |   get  
        |------------|---------------|------------------|
        |0(n) 0(n)   | 0(n) 0(1)     | 0(n)  0(n)       |   insert
        |------------|---------------|------------------|
        |0(n) 0(n)   | 0(n) 0(1)     | 0(n)  0(n)       |   delete
        |------------|---------------|------------------|

    Reverse a Stack
        Already done [existing stack empty karke doosre stack me daal rahe hai for eg. on above st -> temp ]

        1. Use two extra stack get  & repeat to st stack 
        2. Using an extra array 
            a. creating a same size as stack to create a vector 
            b. then pop to push 
            c. then push to original stack 


    Push element at bottom / any index 
         pushAtIndex(st , indexposition , value)
        while(st.size > indexposition){}

    Reverse stack recursively 
        Display a stCK USING recursion
        folloe -> recursionInstack.cpp

    Overflow
        If your stack is full , then if you try to push an element then return error 

    UnderFlow
        If in an empty stack , I try to perform these two functions -> st.pop() , st.top() using this not returning error but and printing anything on terminal 

    Array/Vector Implementation
    Linked List Implementation

    Balanced Bracket 
        (())() true 
        (()() not 
        )()(  not 
        step 1: If you see opening bracket -> push 
        step 2 : if you see a closing bkt , 
            st-> top ko dekho  , agar top pe "(" ho to st.pop()
            else return false
        step 3 :
            if st.empty()  -> true
            else false

    Next greater element
    CanSeePersonCount
    SlidingWindow
    



